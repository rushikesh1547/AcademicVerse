/**
 * This ruleset enforces a security model based on user roles (student, teacher) and strict data ownership.
 * It's designed for rapid prototyping, focusing on authorization (who can access what) rather than
 * strict data validation (the exact shape of the data).
 *
 * Core Philosophy:
 * - Users have full control over their own data, typically stored in subcollections under `/users/{userId}`.
 * - Academic content like Quizzes, Assignments, and Resources is created and managed by teachers but is readable by all authenticated users.
 * - Student submissions (QuizAttempts, AssignmentSubmissions) are owned by the student, but readable by the teacher of the parent content for grading.
 * - Critical data like attendance records is assumed to be written by a trusted backend process (e.g., Cloud Functions) and is locked down from client-side writes.
 * - User enumeration is disabled by disallowing `list` operations on top-level user, student, and teacher collections.
 *
 * Data Structure:
 * The data is organized into a mix of top-level collections for shared academic content (e.g., /quizzes, /assignments)
 * and user-specific subcollections for private data (e.g., /users/{userId}/results, /users/{userId}/notifications). This structural
 * segregation provides a clear and secure separation between private and shared data.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access must be explicitly granted.
 * - Denormalization for Authorization: To ensure performant and secure rules, authorization-critical data (like a studentId on a submission or an uploaderId on a resource) is expected to be denormalized directly onto the documents being secured. This avoids slow and costly cross-document `get()` calls where possible.
 * - Backend-Only Writes: Collections like `students` and `teachers`, which represent official profiles, are restricted from client writes. It's assumed they are managed by an admin or a trusted backend process. The same applies to attendance data, which is generated by a face-recognition backend.
 * - Missing Ownership Fields: For collections like `quizzes`, `assignments`, and `attendanceSessions` where the schema is missing a `teacherId` or `ownerId`, write operations are disabled with a `TODO` comment. This is a critical security measure to prevent unauthorized content creation until the data model is updated.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     * Prevents operations on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for update/delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Checks if the owner of a parent Quiz document matches the requesting user.
     * Assumes the parent quiz has a 'teacherId' field.
     */
    function isQuizOwner(quizId) {
      let quiz = get(/databases/$(database)/documents/quizzes/$(quizId));
      return isSignedIn() && quiz.data.teacherId == request.auth.uid;
    }
    
    /**
     * Checks if the owner of a parent Assignment document matches the requesting user.
     * Assumes the parent assignment has a 'teacherId' field.
     */
    function isAssignmentOwner(assignmentId) {
      let assignment = get(/databases/$(database)/documents/assignments/$(assignmentId));
      return isSignedIn() && assignment.data.teacherId == request.auth.uid;
    }
    
    /**
     * Checks if the owner of a parent Attendance Session document matches the requesting user.
     * Assumes the parent session has a 'teacherId' field.
     */
    function isSessionOwner(sessionId) {
      let session = get(/databases/$(database)/documents/attendanceSessions/$(sessionId));
      return isSignedIn() && session.data.teacherId == request.auth.uid;
    }

    // --------------------------------
    // User & Profile Rules
    // --------------------------------

    /**
     * @description Users can create and manage their own user document. Listing users is disallowed.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user document with a matching UID.
     * @deny (create) A user trying to create a document for another user's UID.
     * @deny (list) Any user trying to list all documents in the /users collection.
     * @principle Enforces self-creation and ownership, and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.authenticationUid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Student profiles are read-only for the owning user. Creation and modification are disabled for clients.
     * @path /students/{studentId}
     * @allow (get) A student fetching their own profile document via its ID.
     * @deny (get) A student trying to fetch another student's profile.
     * @deny (create, update, delete) Any client attempting to modify student records.
     * @principle Secures sensitive profile data, assuming it is managed by a trusted backend.
     */
    match /students/{studentId} {
      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Teacher profiles are read-only for the owning user. Creation and modification are disabled for clients.
     * @path /teachers/{teacherId}
     * @allow (get) A teacher fetching their own profile document via its ID.
     * @deny (get) A teacher trying to fetch another teacher's profile.
     * @deny (create, update, delete) Any client attempting to modify teacher records.
     * @principle Secures sensitive profile data, assuming it is managed by a trusted backend.
     */
    match /teachers/{teacherId} {
      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // --------------------------------
    // Attendance Rules
    // --------------------------------

    /**
     * @description Attendance session info is readable by any signed-in user. Writes are disabled pending schema update.
     * @path /attendanceSessions/{sessionId}
     * @allow (get, list) Any authenticated user can read session details.
     * @deny (create, update, delete) All writes are denied until an ownership field is added.
     * @principle Public read access for course-related info, with writes locked for security.
     */
    match /attendanceSessions/{sessionId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.teacherId == request.auth.uid;
      allow update, delete: if isSessionOwner(sessionId);
    }

    /**
     * @description Attendance interval data is written by the backend. Readable by the relevant student or the session's teacher.
     * @path /attendanceSessions/{sessionId}/attendanceIntervals/{intervalId}
     * @allow (get) A student reading their own attendance interval, or a teacher reading any interval for a session they own.
     * @deny (create, update, delete) All client-side writes are denied.
     * @principle Secures sensitive attendance data, allowing access only to authorized roles.
     */
    match /attendanceSessions/{sessionId}/attendanceIntervals/{intervalId} {
      allow get: if isSignedIn() && (isSessionOwner(sessionId) || resource.data.studentId == request.auth.uid);
      allow list: if isSessionOwner(sessionId) || isSignedIn();
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update, delete: if isExistingDoc() && resource.data.studentId == request.auth.uid;
    }

    /**
     * @description Attendance summary data is written by the backend. Readable by the relevant student or the session's teacher.
     * @path /attendanceSessions/{sessionId}/attendanceSummary/{summaryId}
     * @allow (get) A student reading their own attendance summary, or a teacher reading any summary for a session they own.
     * @deny (create, update, delete) All client-side writes are denied.
     * @principle Secures sensitive attendance data, allowing access only to authorized roles.
     */
    match /attendanceSessions/{sessionId}/attendanceSummary/{summaryId} {
      allow get: if isSignedIn() && (isSessionOwner(sessionId) || resource.data.studentId == request.auth.uid);
      allow list: if isSessionOwner(sessionId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // --------------------------------
    // Academic Content Rules
    // --------------------------------

    /**
     * @description Quizzes are readable by any authenticated user. Writes are disabled pending schema update.
     * @path /quizzes/{quizId}
     * @allow (get, list) Any authenticated user can read quiz details.
     * @deny (create, update, delete) All writes are denied until a teacher ownership field is added.
     * @principle Public read access for academic content, with writes locked for security.
     */
    match /quizzes/{quizId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      // CRITICAL: Cannot implement owner-only writes. The 'Quiz' entity is missing an 'ownerId' or 'teacherId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Quiz questions are readable by any user, but only manageable by the quiz owner.
     * @path /quizzes/{quizId}/quizQuestions/{questionId}
     * @allow (create) The teacher who owns the parent quiz can create questions.
     * @deny (update) A student trying to modify a quiz question.
     * @principle Secures academic content by linking write permissions to parent document ownership.
     */
    match /quizzes/{quizId}/quizQuestions/{questionId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isQuizOwner(quizId);
      allow update: if isQuizOwner(quizId) && isExistingDoc();
      allow delete: if isQuizOwner(quizId) && isExistingDoc();
    }

    /**
     * @description Students can create and manage their own quiz attempts. The quiz owner can read/list attempts for grading.
     * @path /quizzes/{quizId}/quizAttempts/{attemptId}
     * @allow (create) A student submitting an attempt for a quiz, linking it to their own ID.
     * @allow (get) The teacher of the quiz reading a student's attempt.
     * @deny (update) A student trying to modify another student's attempt.
     * @principle Enforces document ownership for students while allowing read access for teachers (graders).
     */
    match /quizzes/{quizId}/quizAttempts/{attemptId} {
      allow get: if (isExistingDoc() && resource.data.studentId == request.auth.uid) || isQuizOwner(quizId);
      allow list: if isQuizOwner(quizId);
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if isExistingDoc() && resource.data.studentId == request.auth.uid;
      allow delete: if isExistingDoc() && resource.data.studentId == request.auth.uid;
    }

    /**
     * @description Assignments are readable by any authenticated user. Writes are disabled pending schema update.
     * @path /assignments/{assignmentId}
     * @allow (get, list) Any authenticated user can read assignment details.
     * @deny (create, update, delete) All writes are denied until a teacher ownership field is added.
     * @principle Public read access for academic content, with writes locked for security.
     */
    match /assignments/{assignmentId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      // CRITICAL: Cannot implement owner-only writes. The 'Assignment' entity is missing an 'ownerId' or 'teacherId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Students can create and manage their own assignment submissions. The assignment owner can read/list them for grading.
     * @path /assignments/{assignmentId}/assignmentSubmissions/{submissionId}
     * @allow (create) A student submitting a solution, linking it to their own ID.
     * @allow (get) The teacher of the assignment reading a student's submission.
     * @deny (update) A student trying to modify another student's submission.
     * @principle Enforces document ownership for students while allowing read access for teachers (graders).
     */
    match /assignments/{assignmentId}/assignmentSubmissions/{submissionId} {
      allow get: if (isExistingDoc() && resource.data.studentId == request.auth.uid) || isAssignmentOwner(assignmentId);
      allow list: if isAssignmentOwner(assignmentId);
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if isExistingDoc() && resource.data.studentId == request.auth.uid;
      allow delete: if isExistingDoc() && resource.data.studentId == request.auth.uid;
    }

    /**
     * @description Resources are readable by any authenticated user. Only the uploading teacher can write.
     * @path /resources/{resourceId}
     * @allow (create) A teacher uploading a new resource and setting themselves as the uploader.
     * @deny (update) A user trying to modify a resource they did not upload.
     * @principle Enforces document ownership for writes on publicly readable content.
     */
    match /resources/{resourceId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.uploaderId == request.auth.uid;
      allow update: if isExistingDoc() && resource.data.uploaderId == request.auth.uid;
      allow delete: if isExistingDoc() && resource.data.uploaderId == request.auth.uid;
    }

    // --------------------------------
    // Student-Owned Document Rules
    // --------------------------------

    /**
     * @description Students can create and manage their own exam forms.
     * @path /examForms/{formId}
     * @allow (create) A student creating their own exam form.
     * @deny (get) Another student trying to read someone else's exam form.
     * @principle Enforces strict document ownership for sensitive student data.
     */
    match /examForms/{formId} {
      allow get: if isExistingDoc() && resource.data.studentId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if isExistingDoc() && resource.data.studentId == request.auth.uid;
      allow delete: if isExistingDoc() && resource.data.studentId == request.auth.uid;
    }

    /**
     * @description Users can only access results within their own user space.
     * @path /users/{userId}/results/{resultId}
     * @allow (get, list, create, update, delete) A user performing any operation on their own results.
     * @deny (get) A user trying to access another user's results.
     * @principle Restricts access to a user's own data tree using path-based security.
     */
    match /users/{userId}/results/{resultId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Users can only access grade cards within their own user space.
     * @path /users/{userId}/gradeCards/{gradeCardId}
     * @allow (get, list, create, update, delete) A user performing any operation on their own grade cards.
     * @deny (get) A user trying to access another user's grade cards.
     * @principle Restricts access to a user's own data tree using path-based security.
     */
    match /users/{userId}/gradeCards/{gradeCardId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Users can only access notifications within their own user space.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (get, list, create, update, delete) A user performing any operation on their own notifications.
     * @deny (get) A user trying to access another user's notifications.
     * @principle Restricts access to a user's own data tree using path-based security.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.recipientId == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}
